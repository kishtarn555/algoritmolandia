<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "TechArticle",
  "description": "Algoritmo de ordenamiento considerado básico por su fácil implementación, e intuición. Sin embargo es también de los más lentos teniendo complejidad $O(N^{2})$, aunque no usa memoria extra.",
  "name": "Ordenamiento por insercion",
  "headline":"Ordenaminto por insercion (Insertion Sort)",
  "inLanguage":"es-xl",
  "sameAs":"https://es.wikipedia.org/wiki/Ordenamiento_por_insercion",
  "keywords":"algoritmo,español,ordenamiento,insercion,sort,insertion,ejemplo,implementación,complejidad",
  "image":"http://algoritmolandia.com/images/articles/sorts/insertion/complete_insertion.gif"
}
</script>
<h1>Ordenamiento por inserción (Insertion sort)</h1>
El <b>Ordenamiento por inserción</b> o <b>Insertion sort</b> es un metodo de ordenamiento que va metiendo elemento por elemento de forma que quede ordenado.
<br>
Similar a cuanto tenemos una baraja de cartas ordenada, cuando nos dan una nueva carta buscamos donde va y la colocamos alli.
<br>
Podemos ver una imagen para entender mejor. El nuevo elemento se ve de color naranja y la baraja se ve verde.<br>
<img src="/images/articles/sorts/insertion/insertion1.gif" class="article-img"/>

<br/>
<br/>
Con esta misma analogia, lo que el insertion sort hace es que inserta el primer elemento en la baraja, de alli inserta a la baraja el segundo elemento, luego el tercero, etc. Siempre manteniendo el orden de la baraja.
<br/>
Todo esto nos permite que al final tengamos todos los elementos ordenados en la baraja.
<br/>
<br/>
Ahora, para insertar un elemento en la baraja, lo que podemos hacer es representar la baraja como un arreglo de tamaño $N$, enumerado del 0 al $N-1$, digamos que queremos insertar un numero, lo colocaremos al final del arreglo, en la posición $N$. Luego, mientras el elemento interior al nuevo sea mayor que él, intercambiaremos el elemento elemento anterior, con el nuevo.<br/> 
Esto se puede volver a observar en la imagen, como el elemento, a base de intercambios, se va moviendo a su posición correcta.<br>
<img src="/images/articles/sorts/insertion/insertion1.gif" class="article-img"/>
<br/>

Ahora, para ordenar todo, lo que hacemos es que dividimos nuestro arreglo en dos, lo que ya esta ordenado (a la izquierda) y lo que falta por ordenar(a la derecha).
Entonces agarramos el primer elemento del grupo desordenado y lo insertamos al grupo izquerdo, lo que hace que el grupo ordenado crezca en tamaño uno y el desordenado decrezca en tamaño 1.
<br/>
Repetimos lo mismo hasta que nuestro gurpo ordenado abarque todos los elementos. Esto lo podemos ver en la siguiente imagen.
<br/>
<img src="/images/articles/sorts/insertion/complete_insertion.gif" class="article-img"/>
<br/>
En general, esta serie de pasos es el ordenamiento por inserción, en la siguente sección hablaremos sobre su implementacion.
<h2>Implementación</h2>
Ahora veremos como implementar el insertion sort.
<pre><code class="cpp">
int n = 8;
int arr[8]={5,2,7,4,3,1,8,6};
void ordenamiento_por_insercion() {
    //iteramos por cada elemento que agregaremos al grupo ordenado.
    //El grupo ordenado abarca de 0 a i-1
    for (int i =0; i &lt; n; i++) {
        int j = i;
        while(j!=0 &amp;&amp; arr[j]&lt;arr[j-1]) {
            //Intercambiar los elementos
            int tm = arr[j];
            tm=arr[j];
            arr[j]=arr[j-1];
            arr[j-1]=tm,
            //Actualizar la j
            j--;
        }
     }

}
    </code></pre>

<h2>Complejidad</h2>
Para analizar la complejidad o velocidad del ordenamiento por inserción, hay que ver que serie de pasos realiza.<br>
El insertion sort, por cada elemento realiza una inserción, y la inserción es recorrer todos los elementos. Es decir que la complejidad es la cantidad de elementos por la cantidad de elementos en otras palabras $O(N^2).$
<br>
Esto se puede observar especialmente en el caso donde el arreglo inicial este ordenado de forma decreciente, y lo quieras ordenar al revez.<br>
Pues la primera inserción, no tomara nada de tiempo, la segunda tomara 1 cambio, la tercera 2 cambios, es decir que necesitara $1+2+3+4+...+N$ cambios, lo cual crece en $O(N^2)$.

